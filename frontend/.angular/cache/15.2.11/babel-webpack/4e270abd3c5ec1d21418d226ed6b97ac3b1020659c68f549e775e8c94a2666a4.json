{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError, of } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class AzureDevOpsService {\n  constructor(http) {\n    this.http = http;\n    // Use our backend API as a proxy\n    this.apiUrl = `${environment.apiUrl}/azure`;\n  }\n  /**\r\n   * Fetch work items for a specific iteration path using our backend proxy\r\n   * @param iterationPath The iteration path to filter by\r\n   * @returns Observable with work items data\r\n   */\n  getWorkItemsByIteration(iterationPath) {\n    // Use our backend proxy endpoint that will handle Azure DevOps auth\n    const url = `${this.apiUrl}/work-items`;\n    // Use URL parameters to pass the iteration path\n    let params = new HttpParams().set('iterationPath', iterationPath);\n    return this.http.get(url, {\n      params\n    }).pipe(catchError(error => {\n      console.error('Error fetching work items by iteration:', error);\n      return throwError(() => new Error('Failed to fetch work items. Please try again.'));\n    }));\n  }\n  /**\r\n   * Get work item counts by status from our backend\r\n   * @param iterationPath The iteration path to filter by\r\n   * @returns Observable with counts by status\r\n   */\n  getWorkItemStatusCounts(iterationPath) {\n    const url = `${this.apiUrl}/work-item-counts`;\n    // Use URL parameters to pass the iteration path\n    let params = new HttpParams().set('iterationPath', iterationPath);\n    return this.http.get(url, {\n      params\n    }).pipe(catchError(error => {\n      console.error('Error fetching work item counts:', error);\n      // Return a default object with zeroes to avoid UI breaking\n      return of({\n        totalTasks: 0,\n        devNew: 0,\n        inProgress: 0,\n        codeReview: 0,\n        devComplete: 0,\n        completed: 0,\n        blocked: 0\n      });\n    }));\n  }\n  /**\r\n   * Process work items to get counts by status - use this as a fallback\r\n   * if the backend endpoint is not yet implemented\r\n   * @param workItems The work items data\r\n   * @returns Object with counts by status\r\n   */\n  getWorkItemCounts(workItems) {\n    const counts = {\n      totalTasks: workItems.length,\n      devNew: 0,\n      inProgress: 0,\n      codeReview: 0,\n      devComplete: 0,\n      completed: 0,\n      blocked: 0\n    };\n    workItems.forEach(item => {\n      const state = item.fields ? item.fields['System.State'] : item.state;\n      // Increment appropriate counter based on state - match the states from the screenshot\n      if (state === 'Dev-New' || state === 'CS-New' || state === 'New') {\n        counts.devNew++;\n      } else if (state === 'Dev In progress' || state === 'Dev-WIP' || state === 'In Progress' || state === 'Active') {\n        counts.inProgress++;\n      } else if (state === 'Code Review' || state === 'Dev-Code Review') {\n        counts.codeReview++;\n      } else if (state === 'Dev Complete' || state === 'Dev-Done' || state === 'Dev-Complete') {\n        counts.devComplete++;\n      } else if (state === 'Completed' || state === 'Closed' || state === 'Done' || state === 'Moved to Production') {\n        counts.completed++;\n      } else if (state === 'Blocked' || state === 'Impediment' || state === 'Awaiting Clarification') {\n        counts.blocked++;\n      }\n    });\n    return counts;\n  }\n  static {\n    this.ɵfac = function AzureDevOpsService_Factory(t) {\n      return new (t || AzureDevOpsService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AzureDevOpsService,\n      factory: AzureDevOpsService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["HttpParams","throwError","of","catchError","environment","AzureDevOpsService","constructor","http","apiUrl","getWorkItemsByIteration","iterationPath","url","params","set","get","pipe","error","console","Error","getWorkItemStatusCounts","totalTasks","devNew","inProgress","codeReview","devComplete","completed","blocked","getWorkItemCounts","workItems","counts","length","forEach","item","state","fields","factory","providedIn"],"sourceRoot":"","sources":["E:\\Project-AI\\AI-Scrum\\frontend\\src\\app\\services\\azure-devops.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';\r\nimport { Observable, throwError, of } from 'rxjs';\r\nimport { catchError, map } from 'rxjs/operators';\r\nimport { environment } from '../../environments/environment';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class AzureDevOpsService {\r\n  // Use our backend API as a proxy\r\n  private apiUrl = `${environment.apiUrl}/azure`;\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  /**\r\n   * Fetch work items for a specific iteration path using our backend proxy\r\n   * @param iterationPath The iteration path to filter by\r\n   * @returns Observable with work items data\r\n   */\r\n  getWorkItemsByIteration(iterationPath: string): Observable<any> {\r\n    // Use our backend proxy endpoint that will handle Azure DevOps auth\r\n    const url = `${this.apiUrl}/work-items`;\r\n    \r\n    // Use URL parameters to pass the iteration path\r\n    let params = new HttpParams().set('iterationPath', iterationPath);\r\n    \r\n    return this.http.get(url, { params }).pipe(\r\n      catchError(error => {\r\n        console.error('Error fetching work items by iteration:', error);\r\n        return throwError(() => new Error('Failed to fetch work items. Please try again.'));\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get work item counts by status from our backend\r\n   * @param iterationPath The iteration path to filter by\r\n   * @returns Observable with counts by status\r\n   */\r\n  getWorkItemStatusCounts(iterationPath: string): Observable<any> {\r\n    const url = `${this.apiUrl}/work-item-counts`;\r\n    \r\n    // Use URL parameters to pass the iteration path\r\n    let params = new HttpParams().set('iterationPath', iterationPath);\r\n    \r\n    return this.http.get(url, { params }).pipe(\r\n      catchError(error => {\r\n        console.error('Error fetching work item counts:', error);\r\n        // Return a default object with zeroes to avoid UI breaking\r\n        return of({\r\n          totalTasks: 0,\r\n          devNew: 0,\r\n          inProgress: 0,\r\n          codeReview: 0,\r\n          devComplete: 0,\r\n          completed: 0,\r\n          blocked: 0\r\n        });\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Process work items to get counts by status - use this as a fallback\r\n   * if the backend endpoint is not yet implemented\r\n   * @param workItems The work items data\r\n   * @returns Object with counts by status\r\n   */\r\n  getWorkItemCounts(workItems: any[]): any {\r\n    const counts = {\r\n      totalTasks: workItems.length,\r\n      devNew: 0,\r\n      inProgress: 0,\r\n      codeReview: 0,\r\n      devComplete: 0,\r\n      completed: 0,\r\n      blocked: 0\r\n    };\r\n\r\n    workItems.forEach(item => {\r\n      const state = item.fields ? item.fields['System.State'] : item.state;\r\n      \r\n      // Increment appropriate counter based on state - match the states from the screenshot\r\n      if (state === 'Dev-New' || state === 'CS-New' || state === 'New') {\r\n        counts.devNew++;\r\n      } else if (state === 'Dev In progress' || state === 'Dev-WIP' || state === 'In Progress' || state === 'Active') {\r\n        counts.inProgress++;\r\n      } else if (state === 'Code Review' || state === 'Dev-Code Review') {\r\n        counts.codeReview++;\r\n      } else if (state === 'Dev Complete' || state === 'Dev-Done' || state === 'Dev-Complete') {\r\n        counts.devComplete++;\r\n      } else if (state === 'Completed' || state === 'Closed' || state === 'Done' || state === 'Moved to Production') {\r\n        counts.completed++;\r\n      } else if (state === 'Blocked' || state === 'Impediment' || state === 'Awaiting Clarification') {\r\n        counts.blocked++;\r\n      }\r\n    });\r\n\r\n    return counts;\r\n  }\r\n} "]},"metadata":{},"sourceType":"module","externalDependencies":[]}