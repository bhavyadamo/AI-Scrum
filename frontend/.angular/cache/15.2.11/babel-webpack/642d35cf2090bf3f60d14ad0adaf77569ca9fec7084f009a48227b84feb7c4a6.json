{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError } from 'rxjs';\nimport { catchError, retry, map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TaskService {\n  constructor(http) {\n    this.http = http;\n    this.apiUrl = `${environment.apiUrl}/tasks`;\n  }\n  /**\r\n   * Get available iteration paths from the API\r\n   * @returns Observable of string array with iteration paths\r\n   */\n  getIterationPaths() {\n    return this.http.get(`${this.apiUrl}/iteration-paths`).pipe(retry(1), catchError(error => this.handleError(error, 'fetching iteration paths')));\n  }\n  /**\r\n   * Get work items by iteration path and optional date range\r\n   * @param iterationPath The iteration path to filter work items by\r\n   * @param fromDate Optional start date for filtering\r\n   * @param toDate Optional end date for filtering\r\n   * @returns Observable of WorkItem array\r\n   */\n  getTasks(iterationPath, fromDate, toDate) {\n    // Use HttpParams for proper URL encoding and query string building\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\n    const encodedIterationPath = encodeURIComponent(iterationPath);\n    let params = new HttpParams().set('iterationPath', encodedIterationPath);\n    if (fromDate) {\n      params = params.set('fromDate', fromDate);\n    }\n    if (toDate) {\n      params = params.set('toDate', toDate);\n    }\n    return this.http.get(this.apiUrl, {\n      params\n    }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching work items')), map(response => this.processWorkItemsResponse(response)));\n  }\n  /**\r\n   * Get detailed information for a specific work item\r\n   * @param taskId The ID of the work item to fetch\r\n   * @returns Observable of WorkItemDetails\r\n   */\n  getTaskDetails(taskId) {\n    return this.http.get(`${this.apiUrl}/${taskId}`).pipe(retry(1), catchError(error => this.handleError(error, `fetching work item #${taskId}`)));\n  }\n  /**\r\n   * Get team members from the API\r\n   * @returns Observable of TeamMember array\r\n   * @deprecated Use TeamService.getTeamMembers() instead\r\n   */\n  getTeamMembers() {\n    return this.http.get(`${this.apiUrl}/team-members`).pipe(retry(1), catchError(error => this.handleError(error, 'fetching team members')));\n  }\n  /**\r\n   * Assign a work item to a team member\r\n   * @param taskId The ID of the work item to assign\r\n   * @param assignedTo The ID or name of the team member to assign the task to\r\n   * @returns Observable of the assignment result\r\n   */\n  assignTask(taskId, assignedTo) {\n    return this.http.post(`${this.apiUrl}/assign`, {\n      taskId,\n      assignedTo\n    }).pipe(catchError(error => this.handleError(error, `assigning work item #${taskId}`)));\n  }\n  /**\r\n   * Get auto-assignment suggestions for tasks in the given iteration\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @returns Observable of task ID to team member ID mapping\r\n   */\n  getAutoAssignSuggestions(iterationPath) {\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\n    const encodedIterationPath = encodeURIComponent(iterationPath);\n    const params = new HttpParams().set('iterationPath', encodedIterationPath);\n    return this.http.get(`${this.apiUrl}/auto-assign-suggestions`, {\n      params\n    }).pipe(catchError(error => this.handleError(error, 'fetching auto-assign suggestions')));\n  }\n  /**\r\n   * Auto-assign tasks in the given iteration\r\n   * @param iterationPath The iteration path containing tasks to auto-assign\r\n   * @returns Observable of the assignment result\r\n   */\n  autoAssignTasks(iterationPath) {\n    // Ensure the iterationPath is properly encoded in the JSON body\n    const encodedIterationPath = encodeURIComponent(iterationPath);\n    return this.http.post(`${this.apiUrl}/auto-assign`, {\n      iterationPath: encodedIterationPath\n    }).pipe(catchError(error => this.handleError(error, 'auto-assigning tasks')));\n  }\n  /**\r\n   * Generic error handler for HTTP requests\r\n   * @param error The HTTP error response\r\n   * @param operation The operation that was being performed\r\n   * @returns An observable that errors with a user-friendly message\r\n   */\n  handleError(error, operation) {\n    let errorMessage = `An error occurred while ${operation}`;\n    if (error.error instanceof ErrorEvent) {\n      // Client-side error\n      errorMessage = `Error: ${error.error.message}`;\n    } else {\n      // Server-side error\n      errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\n      if (error.error?.message) {\n        errorMessage += ` - ${error.error.message}`;\n      }\n    }\n    console.error(errorMessage);\n    return throwError(() => new Error(errorMessage));\n  }\n  /**\r\n   * Process the work items response to ensure consistent structure\r\n   * @param response The raw API response\r\n   * @returns An array of properly formatted WorkItem objects\r\n   */\n  processWorkItemsResponse(response) {\n    if (!Array.isArray(response)) {\n      console.warn('Unexpected response format for work items:', response);\n      return [];\n    }\n    return response.map(item => ({\n      id: item.id,\n      title: item.title || 'Untitled Work Item',\n      state: item.state || 'Unknown',\n      status: item.status,\n      type: item.type,\n      priority: item.priority || 0,\n      assignedTo: item.assignedTo || null,\n      iterationPath: item.iterationPath || ''\n    }));\n  }\n  static {\n    this.ɵfac = function TaskService_Factory(t) {\n      return new (t || TaskService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TaskService,\n      factory: TaskService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["HttpParams","throwError","catchError","retry","map","environment","TaskService","constructor","http","apiUrl","getIterationPaths","get","pipe","error","handleError","getTasks","iterationPath","fromDate","toDate","encodedIterationPath","encodeURIComponent","params","set","response","processWorkItemsResponse","getTaskDetails","taskId","getTeamMembers","assignTask","assignedTo","post","getAutoAssignSuggestions","autoAssignTasks","operation","errorMessage","ErrorEvent","message","status","statusText","console","Error","Array","isArray","warn","item","id","title","state","type","priority","factory","providedIn"],"sourceRoot":"","sources":["E:\\Project-AI\\AI-Scrum\\frontend\\src\\app\\services\\task.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';\r\nimport { Observable, throwError } from 'rxjs';\r\nimport { catchError, retry, map } from 'rxjs/operators';\r\nimport { WorkItem, WorkItemDetails, TeamMember } from '../models/task.model';\r\nimport { environment } from '../../environments/environment';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class TaskService {\r\n  private apiUrl = `${environment.apiUrl}/tasks`;\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  /**\r\n   * Get available iteration paths from the API\r\n   * @returns Observable of string array with iteration paths\r\n   */\r\n  getIterationPaths(): Observable<string[]> {\r\n    return this.http.get<string[]>(`${this.apiUrl}/iteration-paths`)\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching iteration paths'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get work items by iteration path and optional date range\r\n   * @param iterationPath The iteration path to filter work items by\r\n   * @param fromDate Optional start date for filtering\r\n   * @param toDate Optional end date for filtering\r\n   * @returns Observable of WorkItem array\r\n   */\r\n  getTasks(iterationPath: string, fromDate?: string, toDate?: string): Observable<WorkItem[]> {\r\n    // Use HttpParams for proper URL encoding and query string building\r\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\r\n    const encodedIterationPath = encodeURIComponent(iterationPath);\r\n    let params = new HttpParams().set('iterationPath', encodedIterationPath);\r\n    \r\n    if (fromDate) {\r\n      params = params.set('fromDate', fromDate);\r\n    }\r\n    \r\n    if (toDate) {\r\n      params = params.set('toDate', toDate);\r\n    }\r\n    \r\n    return this.http.get<WorkItem[]>(this.apiUrl, { params })\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching work items')),\r\n        map(response => this.processWorkItemsResponse(response))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get detailed information for a specific work item\r\n   * @param taskId The ID of the work item to fetch\r\n   * @returns Observable of WorkItemDetails\r\n   */\r\n  getTaskDetails(taskId: number): Observable<WorkItemDetails> {\r\n    return this.http.get<WorkItemDetails>(`${this.apiUrl}/${taskId}`)\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, `fetching work item #${taskId}`))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get team members from the API\r\n   * @returns Observable of TeamMember array\r\n   * @deprecated Use TeamService.getTeamMembers() instead\r\n   */\r\n  getTeamMembers(): Observable<TeamMember[]> {\r\n    return this.http.get<TeamMember[]>(`${this.apiUrl}/team-members`)\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching team members'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Assign a work item to a team member\r\n   * @param taskId The ID of the work item to assign\r\n   * @param assignedTo The ID or name of the team member to assign the task to\r\n   * @returns Observable of the assignment result\r\n   */\r\n  assignTask(taskId: number, assignedTo: string): Observable<any> {\r\n    return this.http.post<any>(`${this.apiUrl}/assign`, {\r\n      taskId,\r\n      assignedTo\r\n    }).pipe(\r\n      catchError(error => this.handleError(error, `assigning work item #${taskId}`))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get auto-assignment suggestions for tasks in the given iteration\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @returns Observable of task ID to team member ID mapping\r\n   */\r\n  getAutoAssignSuggestions(iterationPath: string): Observable<Record<string, string>> {\r\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\r\n    const encodedIterationPath = encodeURIComponent(iterationPath);\r\n    const params = new HttpParams().set('iterationPath', encodedIterationPath);\r\n\r\n    return this.http.get<Record<string, string>>(`${this.apiUrl}/auto-assign-suggestions`, { params })\r\n      .pipe(\r\n        catchError(error => this.handleError(error, 'fetching auto-assign suggestions'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Auto-assign tasks in the given iteration\r\n   * @param iterationPath The iteration path containing tasks to auto-assign\r\n   * @returns Observable of the assignment result\r\n   */\r\n  autoAssignTasks(iterationPath: string): Observable<any> {\r\n    // Ensure the iterationPath is properly encoded in the JSON body\r\n    const encodedIterationPath = encodeURIComponent(iterationPath);\r\n    return this.http.post<any>(`${this.apiUrl}/auto-assign`, {\r\n      iterationPath: encodedIterationPath\r\n    }).pipe(\r\n      catchError(error => this.handleError(error, 'auto-assigning tasks'))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generic error handler for HTTP requests\r\n   * @param error The HTTP error response\r\n   * @param operation The operation that was being performed\r\n   * @returns An observable that errors with a user-friendly message\r\n   */\r\n  private handleError(error: HttpErrorResponse, operation: string): Observable<never> {\r\n    let errorMessage = `An error occurred while ${operation}`;\r\n    \r\n    if (error.error instanceof ErrorEvent) {\r\n      // Client-side error\r\n      errorMessage = `Error: ${error.error.message}`;\r\n    } else {\r\n      // Server-side error\r\n      errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\r\n      if (error.error?.message) {\r\n        errorMessage += ` - ${error.error.message}`;\r\n      }\r\n    }\r\n    \r\n    console.error(errorMessage);\r\n    return throwError(() => new Error(errorMessage));\r\n  }\r\n\r\n  /**\r\n   * Process the work items response to ensure consistent structure\r\n   * @param response The raw API response\r\n   * @returns An array of properly formatted WorkItem objects\r\n   */\r\n  private processWorkItemsResponse(response: any): WorkItem[] {\r\n    if (!Array.isArray(response)) {\r\n      console.warn('Unexpected response format for work items:', response);\r\n      return [];\r\n    }\r\n    \r\n    return response.map(item => ({\r\n      id: item.id,\r\n      title: item.title || 'Untitled Work Item',\r\n      state: item.state || 'Unknown',\r\n      status: item.status,\r\n      type: item.type,\r\n      priority: item.priority || 0,\r\n      assignedTo: item.assignedTo || null,\r\n      iterationPath: item.iterationPath || '',\r\n    }));\r\n  }\r\n} "]},"metadata":{},"sourceType":"module","externalDependencies":[]}