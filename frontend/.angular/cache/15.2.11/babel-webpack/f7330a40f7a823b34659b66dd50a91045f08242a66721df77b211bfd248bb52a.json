{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError } from 'rxjs';\nimport { catchError, retry, map, tap } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TaskService {\n  constructor(http) {\n    this.http = http;\n    this.apiUrl = `${environment.apiUrl}/tasks`;\n  }\n  /**\r\n   * Get available iteration paths from the API\r\n   * @returns Observable of string array with iteration paths\r\n   */\n  getIterationPaths() {\n    return this.http.get(`${this.apiUrl}/iteration-paths`).pipe(retry(1), catchError(error => this.handleError(error, 'fetching iteration paths')));\n  }\n  /**\r\n   * Get work items by iteration path and optional date range\r\n   * @param iterationPath The iteration path to filter work items by\r\n   * @param fromDate Optional start date for filtering\r\n   * @param toDate Optional end date for filtering\r\n   * @returns Observable of WorkItem array\r\n   */\n  getTasks(iterationPath, fromDate, toDate) {\n    // Use HttpParams for proper URL encoding and query string building\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\n    const encodedIterationPath = encodeURIComponent(iterationPath);\n    let params = new HttpParams().set('iterationPath', encodedIterationPath);\n    if (fromDate) {\n      params = params.set('fromDate', fromDate);\n    }\n    if (toDate) {\n      params = params.set('toDate', toDate);\n    }\n    return this.http.get(this.apiUrl, {\n      params\n    }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching work items')), map(response => this.processWorkItemsResponse(response)));\n  }\n  /**\r\n   * Get detailed information for a specific work item\r\n   * @param taskId The ID of the work item to fetch\r\n   * @returns Observable of WorkItemDetails\r\n   */\n  getTaskDetails(taskId) {\n    return this.http.get(`${this.apiUrl}/${taskId}`).pipe(retry(1), catchError(error => this.handleError(error, `fetching work item #${taskId}`)));\n  }\n  /**\r\n   * Get team members from the API\r\n   * @param iterationPath Optional iteration path to filter team members\r\n   * @returns Observable of TeamMember array or string array depending on the iterationPath\r\n   */\n  getTeamMembers(iterationPath) {\n    let params = new HttpParams();\n    if (iterationPath) {\n      // Manually encode the iterationPath to ensure backslashes are correctly encoded\n      const encodedIterationPath = encodeURIComponent(iterationPath);\n      params = params.set('iterationPath', encodedIterationPath);\n    }\n    return this.http.get(`${this.apiUrl}/team-members`, {\n      params\n    }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching team members')));\n  }\n  /**\r\n   * Assign a work item to a team member\r\n   * @param taskId The ID of the work item to assign\r\n   * @param assignedTo The ID or name of the team member to assign the task to\r\n   * @returns Observable of the assignment result\r\n   */\n  assignTask(taskId, assignedTo) {\n    return this.http.post(`${this.apiUrl}/assign`, {\n      taskId,\n      assignedTo\n    }).pipe(catchError(error => this.handleError(error, `assigning work item #${taskId}`)));\n  }\n  /**\r\n   * Get auto-assign suggestions for tasks in the given iteration\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @returns Observable of task ID to suggested assignee mapping\r\n   */\n  getAutoAssignSuggestions(iterationPath) {\n    // Ensure the iterationPath is properly encoded\n    const params = new HttpParams().set('iterationPath', encodeURIComponent(iterationPath));\n    return this.http.get(`${this.apiUrl}/auto-assign-suggestions`, {\n      params\n    }).pipe(catchError(error => this.handleError(error, 'getting auto-assign suggestions')));\n  }\n  /**\r\n   * Get auto-assign suggestions for tasks in the given iteration, filtered for specific team members\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @param teamMembers List of team member names to consider for assignment\r\n   * @returns Observable of task ID to suggested assignee mapping\r\n   */\n  getAutoAssignSuggestionsForTeam(iterationPath, teamMembers) {\n    // Log request details for debugging\n    console.log(`Getting auto-assign suggestions for team with iteration path: ${iterationPath}`);\n    console.log(`Team members (${teamMembers.length}):`, teamMembers);\n    // Normalize the iteration path (replace double backslashes with single)\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n    // Create the request body - ensure iterationPath is properly included\n    const requestBody = {\n      iterationPath: normalizedPath,\n      teamMembers: teamMembers\n    };\n    console.log('Sending request to auto-assign-suggestions/team with payload:', JSON.stringify(requestBody));\n    return this.http.post(`${this.apiUrl}/auto-assign-suggestions/team`, requestBody).pipe(tap(response => console.log('Auto-assign suggestions for team response:', response)), catchError(error => {\n      console.error('Error getting team-specific auto-assign suggestions:', error);\n      console.error('Request payload was:', JSON.stringify(requestBody));\n      return this.handleError(error, 'getting team-specific auto-assign suggestions');\n    }));\n  }\n  /**\r\n   * Auto-assign tasks in the given iteration\r\n   * @param iterationPath The iteration path containing tasks to auto-assign\r\n   * @returns Observable of the assignment result\r\n   */\n  autoAssignTasks(iterationPath) {\n    // Ensure the iterationPath is properly encoded in the JSON body\n    const encodedIterationPath = encodeURIComponent(iterationPath);\n    return this.http.post(`${this.apiUrl}/auto-assign`, {\n      iterationPath: encodedIterationPath\n    }).pipe(catchError(error => this.handleError(error, 'auto-assigning tasks')));\n  }\n  /**\r\n   * Get task counts for each team member in a given iteration\r\n   * @param iterationPath The iteration path to get task counts for\r\n   * @returns Observable of team member names to task count mapping\r\n   */\n  getTeamMemberTaskCounts(iterationPath) {\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\n    const encodedIterationPath = encodeURIComponent(iterationPath);\n    const params = new HttpParams().set('iterationPath', encodedIterationPath);\n    return this.http.get(`${this.apiUrl}/team-member-task-counts`, {\n      params\n    }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching team member task counts')));\n  }\n  /**\r\n   * Generic error handler for HTTP requests\r\n   * @param error The HTTP error response\r\n   * @param operation The operation that was being performed\r\n   * @returns An observable that errors with a user-friendly message\r\n   */\n  handleError(error, operation) {\n    let errorMessage = `An error occurred while ${operation}`;\n    if (error.error instanceof ErrorEvent) {\n      // Client-side error\n      errorMessage = `Error: ${error.error.message}`;\n    } else {\n      // Server-side error\n      errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\n      if (error.error?.message) {\n        errorMessage += ` - ${error.error.message}`;\n      }\n    }\n    console.error(errorMessage);\n    return throwError(() => new Error(errorMessage));\n  }\n  /**\r\n   * Process the work items response to ensure consistent structure\r\n   * @param response The raw API response\r\n   * @returns An array of properly formatted WorkItem objects\r\n   */\n  processWorkItemsResponse(response) {\n    if (!Array.isArray(response)) {\n      console.warn('Unexpected response format for work items:', response);\n      return [];\n    }\n    return response.map(item => ({\n      id: item.id,\n      title: item.title || 'Untitled Work Item',\n      state: item.state || 'Unknown',\n      status: item.status,\n      type: item.type,\n      priority: item.priority || 0,\n      assignedTo: item.assignedTo || null,\n      iterationPath: item.iterationPath || ''\n    }));\n  }\n  static {\n    this.ɵfac = function TaskService_Factory(t) {\n      return new (t || TaskService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TaskService,\n      factory: TaskService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["HttpParams","throwError","catchError","retry","map","tap","environment","TaskService","constructor","http","apiUrl","getIterationPaths","get","pipe","error","handleError","getTasks","iterationPath","fromDate","toDate","encodedIterationPath","encodeURIComponent","params","set","response","processWorkItemsResponse","getTaskDetails","taskId","getTeamMembers","assignTask","assignedTo","post","getAutoAssignSuggestions","getAutoAssignSuggestionsForTeam","teamMembers","console","log","length","normalizedPath","replace","requestBody","JSON","stringify","autoAssignTasks","getTeamMemberTaskCounts","operation","errorMessage","ErrorEvent","message","status","statusText","Error","Array","isArray","warn","item","id","title","state","type","priority","factory","providedIn"],"sourceRoot":"","sources":["E:\\Project-AI\\AI-Scrum\\frontend\\src\\app\\services\\task.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';\r\nimport { Observable, throwError } from 'rxjs';\r\nimport { catchError, retry, map, tap } from 'rxjs/operators';\r\nimport { WorkItem, WorkItemDetails, TeamMember } from '../models/task.model';\r\nimport { environment } from '../../environments/environment';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class TaskService {\r\n  private apiUrl = `${environment.apiUrl}/tasks`;\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  /**\r\n   * Get available iteration paths from the API\r\n   * @returns Observable of string array with iteration paths\r\n   */\r\n  getIterationPaths(): Observable<string[]> {\r\n    return this.http.get<string[]>(`${this.apiUrl}/iteration-paths`)\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching iteration paths'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get work items by iteration path and optional date range\r\n   * @param iterationPath The iteration path to filter work items by\r\n   * @param fromDate Optional start date for filtering\r\n   * @param toDate Optional end date for filtering\r\n   * @returns Observable of WorkItem array\r\n   */\r\n  getTasks(iterationPath: string, fromDate?: string, toDate?: string): Observable<WorkItem[]> {\r\n    // Use HttpParams for proper URL encoding and query string building\r\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\r\n    const encodedIterationPath = encodeURIComponent(iterationPath);\r\n    let params = new HttpParams().set('iterationPath', encodedIterationPath);\r\n    \r\n    if (fromDate) {\r\n      params = params.set('fromDate', fromDate);\r\n    }\r\n    \r\n    if (toDate) {\r\n      params = params.set('toDate', toDate);\r\n    }\r\n    \r\n    return this.http.get<WorkItem[]>(this.apiUrl, { params })\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching work items')),\r\n        map(response => this.processWorkItemsResponse(response))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get detailed information for a specific work item\r\n   * @param taskId The ID of the work item to fetch\r\n   * @returns Observable of WorkItemDetails\r\n   */\r\n  getTaskDetails(taskId: number): Observable<WorkItemDetails> {\r\n    return this.http.get<WorkItemDetails>(`${this.apiUrl}/${taskId}`)\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, `fetching work item #${taskId}`))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get team members from the API\r\n   * @param iterationPath Optional iteration path to filter team members\r\n   * @returns Observable of TeamMember array or string array depending on the iterationPath\r\n   */\r\n  getTeamMembers(iterationPath?: string): Observable<TeamMember[] | string[]> {\r\n    let params = new HttpParams();\r\n    \r\n    if (iterationPath) {\r\n      // Manually encode the iterationPath to ensure backslashes are correctly encoded\r\n      const encodedIterationPath = encodeURIComponent(iterationPath);\r\n      params = params.set('iterationPath', encodedIterationPath);\r\n    }\r\n    \r\n    return this.http.get<TeamMember[] | string[]>(`${this.apiUrl}/team-members`, { params })\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching team members'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Assign a work item to a team member\r\n   * @param taskId The ID of the work item to assign\r\n   * @param assignedTo The ID or name of the team member to assign the task to\r\n   * @returns Observable of the assignment result\r\n   */\r\n  assignTask(taskId: number, assignedTo: string): Observable<any> {\r\n    return this.http.post<any>(`${this.apiUrl}/assign`, {\r\n      taskId,\r\n      assignedTo\r\n    }).pipe(\r\n      catchError(error => this.handleError(error, `assigning work item #${taskId}`))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get auto-assign suggestions for tasks in the given iteration\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @returns Observable of task ID to suggested assignee mapping\r\n   */\r\n  getAutoAssignSuggestions(iterationPath: string): Observable<Record<string, string>> {\r\n    // Ensure the iterationPath is properly encoded\r\n    const params = new HttpParams().set('iterationPath', encodeURIComponent(iterationPath));\r\n    \r\n    return this.http.get<Record<string, string>>(`${this.apiUrl}/auto-assign-suggestions`, { params }).pipe(\r\n      catchError(error => this.handleError(error, 'getting auto-assign suggestions'))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get auto-assign suggestions for tasks in the given iteration, filtered for specific team members\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @param teamMembers List of team member names to consider for assignment\r\n   * @returns Observable of task ID to suggested assignee mapping\r\n   */\r\n  getAutoAssignSuggestionsForTeam(iterationPath: string, teamMembers: string[]): Observable<Record<string, string>> {\r\n    // Log request details for debugging\r\n    console.log(`Getting auto-assign suggestions for team with iteration path: ${iterationPath}`);\r\n    console.log(`Team members (${teamMembers.length}):`, teamMembers);\r\n    \r\n    // Normalize the iteration path (replace double backslashes with single)\r\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\r\n    \r\n    // Create the request body - ensure iterationPath is properly included\r\n    const requestBody = {\r\n      iterationPath: normalizedPath,\r\n      teamMembers: teamMembers\r\n    };\r\n\r\n    console.log('Sending request to auto-assign-suggestions/team with payload:', JSON.stringify(requestBody));\r\n    \r\n    return this.http.post<Record<string, string>>(`${this.apiUrl}/auto-assign-suggestions/team`, requestBody)\r\n      .pipe(\r\n        tap(response => console.log('Auto-assign suggestions for team response:', response)),\r\n        catchError(error => {\r\n          console.error('Error getting team-specific auto-assign suggestions:', error);\r\n          console.error('Request payload was:', JSON.stringify(requestBody));\r\n          return this.handleError(error, 'getting team-specific auto-assign suggestions');\r\n        })\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Auto-assign tasks in the given iteration\r\n   * @param iterationPath The iteration path containing tasks to auto-assign\r\n   * @returns Observable of the assignment result\r\n   */\r\n  autoAssignTasks(iterationPath: string): Observable<any> {\r\n    // Ensure the iterationPath is properly encoded in the JSON body\r\n    const encodedIterationPath = encodeURIComponent(iterationPath);\r\n    return this.http.post<any>(`${this.apiUrl}/auto-assign`, {\r\n      iterationPath: encodedIterationPath\r\n    }).pipe(\r\n      catchError(error => this.handleError(error, 'auto-assigning tasks'))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get task counts for each team member in a given iteration\r\n   * @param iterationPath The iteration path to get task counts for\r\n   * @returns Observable of team member names to task count mapping\r\n   */\r\n  getTeamMemberTaskCounts(iterationPath: string): Observable<Record<string, number>> {\r\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\r\n    const encodedIterationPath = encodeURIComponent(iterationPath);\r\n    const params = new HttpParams().set('iterationPath', encodedIterationPath);\r\n\r\n    return this.http.get<Record<string, number>>(`${this.apiUrl}/team-member-task-counts`, { params })\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching team member task counts'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Generic error handler for HTTP requests\r\n   * @param error The HTTP error response\r\n   * @param operation The operation that was being performed\r\n   * @returns An observable that errors with a user-friendly message\r\n   */\r\n  private handleError(error: HttpErrorResponse, operation: string): Observable<never> {\r\n    let errorMessage = `An error occurred while ${operation}`;\r\n    \r\n    if (error.error instanceof ErrorEvent) {\r\n      // Client-side error\r\n      errorMessage = `Error: ${error.error.message}`;\r\n    } else {\r\n      // Server-side error\r\n      errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\r\n      if (error.error?.message) {\r\n        errorMessage += ` - ${error.error.message}`;\r\n      }\r\n    }\r\n    \r\n    console.error(errorMessage);\r\n    return throwError(() => new Error(errorMessage));\r\n  }\r\n\r\n  /**\r\n   * Process the work items response to ensure consistent structure\r\n   * @param response The raw API response\r\n   * @returns An array of properly formatted WorkItem objects\r\n   */\r\n  private processWorkItemsResponse(response: any): WorkItem[] {\r\n    if (!Array.isArray(response)) {\r\n      console.warn('Unexpected response format for work items:', response);\r\n      return [];\r\n    }\r\n    \r\n    return response.map(item => ({\r\n      id: item.id,\r\n      title: item.title || 'Untitled Work Item',\r\n      state: item.state || 'Unknown',\r\n      status: item.status,\r\n      type: item.type,\r\n      priority: item.priority || 0,\r\n      assignedTo: item.assignedTo || null,\r\n      iterationPath: item.iterationPath || '',\r\n    }));\r\n  }\r\n} "]},"metadata":{},"sourceType":"module","externalDependencies":[]}