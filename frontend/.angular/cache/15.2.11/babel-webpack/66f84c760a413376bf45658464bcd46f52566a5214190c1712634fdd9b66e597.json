{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError, of, switchMap } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let AzureDevOpsService = /*#__PURE__*/(() => {\n  class AzureDevOpsService {\n    constructor(http) {\n      this.http = http;\n      // Use our backend API as a proxy\n      this.apiUrl = `${environment.apiUrl}/azure`;\n      this.azureDevOpsUrl = environment.azureDevOpsUrl;\n      this.organization = environment.organization;\n      this.project = environment.project;\n    }\n    /**\r\n     * Fetch work items for a specific iteration path using our backend proxy\r\n     * @param iterationPath The iteration path to filter by\r\n     * @returns Observable with work items data\r\n     */\n    getWorkItemsByIteration(iterationPath) {\n      // Use our backend proxy endpoint that will handle Azure DevOps auth\n      const url = `${this.apiUrl}/work-items`;\n      // Use URL parameters to pass the iteration path\n      let params = new HttpParams().set('iterationPath', iterationPath);\n      return this.http.get(url, {\n        params\n      }).pipe(catchError(error => {\n        console.error('Error fetching work items by iteration:', error);\n        return throwError(() => new Error('Failed to fetch work items. Please try again.'));\n      }));\n    }\n    /**\r\n     * Get work item counts by status from our backend\r\n     * @param iterationPath The iteration path to filter by\r\n     * @returns Observable with counts by status\r\n     */\n    getWorkItemStatusCounts(iterationPath) {\n      const url = `${this.apiUrl}/work-item-counts`;\n      // Use URL parameters to pass the iteration path\n      let params = new HttpParams().set('iterationPath', iterationPath);\n      return this.http.get(url, {\n        params\n      }).pipe(catchError(error => {\n        console.error('Error fetching work item counts:', error);\n        // Return a default object with zeroes to avoid UI breaking\n        return of({\n          totalTasks: 0,\n          devNew: 0,\n          inProgress: 0,\n          codeReview: 0,\n          devComplete: 0,\n          completed: 0,\n          blocked: 0\n        });\n      }));\n    }\n    /**\r\n     * Process work items to get counts by status - use this as a fallback\r\n     * if the backend endpoint is not yet implemented\r\n     * @param workItems The work items data\r\n     * @returns Object with counts by status\r\n     */\n    getWorkItemCounts(workItems) {\n      const counts = {\n        totalTasks: workItems.length,\n        devNew: 0,\n        inProgress: 0,\n        codeReview: 0,\n        devComplete: 0,\n        completed: 0,\n        blocked: 0\n      };\n      workItems.forEach(item => {\n        const state = item.fields ? item.fields['System.State'] : item.state;\n        // Increment appropriate counter based on state - match the states from the screenshot\n        if (state === 'Dev-New' || state === 'CS-New' || state === 'New') {\n          counts.devNew++;\n        } else if (state === 'Dev In progress' || state === 'Dev-WIP' || state === 'In Progress' || state === 'Active') {\n          counts.inProgress++;\n        } else if (state === 'Code Review' || state === 'Dev-Code Review') {\n          counts.codeReview++;\n        } else if (state === 'Dev Complete' || state === 'Dev-Done' || state === 'Dev-Complete') {\n          counts.devComplete++;\n        } else if (state === 'Completed' || state === 'Closed' || state === 'Done' || state === 'Moved to Production') {\n          counts.completed++;\n        } else if (state === 'Blocked' || state === 'Impediment' || state === 'Awaiting Clarification') {\n          counts.blocked++;\n        }\n      });\n      return counts;\n    }\n    /**\r\n     * Fetch work items using the WIQL API for a specific iteration\r\n     * @param iterationPath The iteration path to filter by (e.g. 'Techoil\\2.3.23')\r\n     * @returns Observable with dashboard statistics including counts by status and assignee\r\n     */\n    getWorkItemsByWiql(iterationPath) {\n      // Direct call to Azure DevOps WIQL API\n      const url = `${this.azureDevOpsUrl}/${this.organization}/${this.project}/_apis/wit/wiql?api-version=7.0`;\n      // WIQL query to filter by iteration path and work item type\n      const wiqlQuery = {\n        query: `SELECT [System.Id], [System.WorkItemType], [System.Title], [System.State], [System.AssignedTo], [System.Tags] \n              FROM WorkItems \n              WHERE [System.IterationPath] = '${iterationPath}' \n              AND [System.WorkItemType] = 'Task'`\n      };\n      // First get the work item IDs from the WIQL query\n      return this.http.post(url, wiqlQuery).pipe(switchMap(result => {\n        // If no work items found, return empty stats\n        if (!result.workItems || result.workItems.length === 0) {\n          return of({\n            totalTasks: 0,\n            devNew: 0,\n            inProgress: 0,\n            codeReview: 0,\n            devComplete: 0,\n            completed: 0,\n            blocked: 0,\n            statsByAssignee: {}\n          });\n        }\n        // Extract work item IDs\n        const ids = result.workItems.map(item => item.id);\n        // Batch GET the work items to get full details including fields\n        const batchUrl = `${this.azureDevOpsUrl}/${this.organization}/${this.project}/_apis/wit/workitems?ids=${ids.join(',')}&fields=System.Id,System.WorkItemType,System.Title,System.State,System.AssignedTo,System.Tags&api-version=7.0`;\n        // Get full work item details\n        return this.http.get(batchUrl).pipe(map(workItemsResult => {\n          // Map work items to a more usable format with state directly accessible\n          const workItems = workItemsResult.value.map(item => {\n            return {\n              id: item.id,\n              title: item.fields['System.Title'] || '',\n              state: item.fields['System.State'] || 'Unknown',\n              assignedTo: item.fields['System.AssignedTo'] ? item.fields['System.AssignedTo'].displayName : 'Unassigned',\n              tags: item.fields['System.Tags'] || '',\n              type: item.fields['System.WorkItemType'] || 'Task',\n              // Keep original fields for reference\n              fields: item.fields\n            };\n          });\n          // Process work items to get counts by status\n          const counts = this.getWorkItemCounts(workItems);\n          // Process work items to get counts by assignee\n          const statsByAssignee = {};\n          workItems.forEach(item => {\n            const state = item.state;\n            const assignee = item.assignedTo || 'Unassigned';\n            // Initialize assignee object if it doesn't exist\n            if (!statsByAssignee[assignee]) {\n              statsByAssignee[assignee] = {\n                total: 0,\n                devNew: 0,\n                inProgress: 0,\n                codeReview: 0,\n                devComplete: 0,\n                completed: 0,\n                blocked: 0\n              };\n            }\n            // Increment total count for this assignee\n            statsByAssignee[assignee].total++;\n            // Increment appropriate state counter for this assignee\n            if (state === 'Dev-New' || state === 'CS-New' || state === 'New') {\n              statsByAssignee[assignee].devNew++;\n            } else if (state === 'Dev In progress' || state === 'Dev-WIP' || state === 'In Progress' || state === 'Active') {\n              statsByAssignee[assignee].inProgress++;\n            } else if (state === 'Code Review' || state === 'Dev-Code Review') {\n              statsByAssignee[assignee].codeReview++;\n            } else if (state === 'Dev Complete' || state === 'Dev-Done' || state === 'Dev-Complete') {\n              statsByAssignee[assignee].devComplete++;\n            } else if (state === 'Completed' || state === 'Closed' || state === 'Done' || state === 'Moved to Production') {\n              statsByAssignee[assignee].completed++;\n            } else if (state === 'Blocked' || state === 'Impediment' || state === 'Awaiting Clarification') {\n              statsByAssignee[assignee].blocked++;\n            }\n          });\n          // Return combined statistics\n          return {\n            ...counts,\n            workItems,\n            statsByAssignee\n          };\n        }));\n      }), catchError(error => {\n        console.error('Error fetching work items with WIQL:', error);\n        return of({\n          totalTasks: 0,\n          devNew: 0,\n          inProgress: 0,\n          codeReview: 0,\n          devComplete: 0,\n          completed: 0,\n          blocked: 0,\n          statsByAssignee: {}\n        });\n      }));\n    }\n    static {\n      this.ɵfac = function AzureDevOpsService_Factory(t) {\n        return new (t || AzureDevOpsService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: AzureDevOpsService,\n        factory: AzureDevOpsService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return AzureDevOpsService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}