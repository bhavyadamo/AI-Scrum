{"ast":null,"code":"import { of, throwError } from 'rxjs';\nimport { catchError, map, switchMap } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class AzureDashboardService {\n  constructor(http) {\n    this.http = http;\n    this.azureDevOpsUrl = environment.azureDevOpsUrl;\n    this.organization = environment.organization;\n    this.project = environment.project;\n  }\n  /**\r\n   * Get dashboard statistics using WIQL API for a specific iteration\r\n   * @param iterationPath The iteration path to filter by (e.g. 'Techoil\\2.3.23')\r\n   * @returns Observable with dashboard statistics including counts by status, assignee, and root cause\r\n   */\n  getDashboardStats(iterationPath) {\n    // URL for WIQL API\n    const wiqlUrl = `${this.azureDevOpsUrl}/${this.organization}/${this.project}/_apis/wit/wiql?api-version=7.0`;\n    // Construct WIQL query to filter by iteration path\n    const wiqlQuery = {\n      query: `SELECT [System.Id], [System.Title], [System.State], [System.WorkItemType], [System.AssignedTo], [Custom.RootCause]\n              FROM WorkItems\n              WHERE [System.IterationPath] = '${iterationPath}'\n              AND [System.TeamProject] = '${this.project}'`\n    };\n    // Execute WIQL query to get work item IDs\n    return this.http.post(wiqlUrl, wiqlQuery).pipe(switchMap(result => {\n      // If no work items found, return empty stats\n      if (!result.workItems || result.workItems.length === 0) {\n        return of({\n          totalItems: 0,\n          statusCounts: {},\n          assigneeCounts: {},\n          rootCauseCounts: [],\n          workItems: []\n        });\n      }\n      // Extract work item IDs\n      const ids = result.workItems.map(item => item.id);\n      // URL for batch API to get full work item details\n      const batchUrl = `${this.azureDevOpsUrl}/${this.organization}/${this.project}/_apis/wit/workitems?ids=${ids.join(',')}&fields=System.Id,System.Title,System.State,System.WorkItemType,System.AssignedTo,Custom.RootCause&api-version=7.0`;\n      // Get work item details\n      return this.http.get(batchUrl).pipe(map(workItemsResult => {\n        const workItems = workItemsResult.value;\n        // Process work items to calculate statistics\n        return this.processWorkItems(workItems);\n      }));\n    }), catchError(error => {\n      console.error('Error fetching dashboard statistics:', error);\n      return throwError(() => new Error('Failed to fetch dashboard statistics. Please try again.'));\n    }));\n  }\n  /**\r\n   * Process work items to calculate dashboard statistics\r\n   * @param workItems Array of work items to process\r\n   * @returns Dashboard statistics\r\n   */\n  processWorkItems(workItems) {\n    const statusCounts = {};\n    const assigneeCounts = {};\n    const rootCausesMap = {};\n    // Process each work item\n    workItems.forEach(item => {\n      const state = item.fields['System.State'] || 'Unknown';\n      const assignee = item.fields['System.AssignedTo'] ? item.fields['System.AssignedTo'].displayName : 'Unassigned';\n      const rootCause = item.fields['Custom.RootCause'] || 'Unspecified';\n      // Count by status\n      statusCounts[state] = (statusCounts[state] || 0) + 1;\n      // Count by assignee and status\n      if (!assigneeCounts[assignee]) {\n        assigneeCounts[assignee] = {\n          total: 0,\n          states: {}\n        };\n      }\n      assigneeCounts[assignee].total++;\n      assigneeCounts[assignee].states[state] = (assigneeCounts[assignee].states[state] || 0) + 1;\n      // Count by root cause and status\n      if (!rootCausesMap[rootCause]) {\n        rootCausesMap[rootCause] = {\n          count: 0,\n          states: {}\n        };\n      }\n      rootCausesMap[rootCause].count++;\n      rootCausesMap[rootCause].states[state] = (rootCausesMap[rootCause].states[state] || 0) + 1;\n    });\n    // Convert root causes to array format\n    const rootCauseCounts = Object.keys(rootCausesMap).map(rootCause => ({\n      rootCause,\n      count: rootCausesMap[rootCause].count,\n      states: rootCausesMap[rootCause].states\n    })).sort((a, b) => b.count - a.count); // Sort by count descending\n    return {\n      totalItems: workItems.length,\n      statusCounts,\n      assigneeCounts,\n      rootCauseCounts,\n      workItems\n    };\n  }\n  static {\n    this.ɵfac = function AzureDashboardService_Factory(t) {\n      return new (t || AzureDashboardService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AzureDashboardService,\n      factory: AzureDashboardService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["of","throwError","catchError","map","switchMap","environment","AzureDashboardService","constructor","http","azureDevOpsUrl","organization","project","getDashboardStats","iterationPath","wiqlUrl","wiqlQuery","query","post","pipe","result","workItems","length","totalItems","statusCounts","assigneeCounts","rootCauseCounts","ids","item","id","batchUrl","join","get","workItemsResult","value","processWorkItems","error","console","Error","rootCausesMap","forEach","state","fields","assignee","displayName","rootCause","total","states","count","Object","keys","sort","a","b","factory","providedIn"],"sourceRoot":"","sources":["E:\\Project-AI\\AI-Scrum\\frontend\\src\\app\\services\\azure-dashboard.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Observable, of, throwError } from 'rxjs';\r\nimport { catchError, map, switchMap } from 'rxjs/operators';\r\nimport { environment } from '../../environments/environment';\r\n\r\nexport interface WorkItem {\r\n  id: number;\r\n  fields: {\r\n    'System.State': string;\r\n    'System.AssignedTo'?: {\r\n      displayName: string;\r\n      uniqueName: string;\r\n    };\r\n    'System.Tags'?: string;\r\n    'System.Title'?: string;\r\n    'System.WorkItemType'?: string;\r\n    'Custom.RootCause'?: string;\r\n  };\r\n}\r\n\r\nexport interface WorkItemQueryResult {\r\n  workItems: { id: number }[];\r\n  columns?: any[];\r\n  workItemRelations?: any[];\r\n}\r\n\r\nexport interface GroupByRootCause {\r\n  rootCause: string;\r\n  count: number;\r\n  states: {\r\n    [state: string]: number;\r\n  };\r\n}\r\n\r\nexport interface DashboardStats {\r\n  totalItems: number;\r\n  statusCounts: {\r\n    [status: string]: number;\r\n  };\r\n  assigneeCounts: {\r\n    [assignee: string]: {\r\n      total: number;\r\n      states: {\r\n        [state: string]: number;\r\n      };\r\n    };\r\n  };\r\n  rootCauseCounts: GroupByRootCause[];\r\n  workItems?: WorkItem[];\r\n}\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class AzureDashboardService {\r\n  private azureDevOpsUrl = environment.azureDevOpsUrl;\r\n  private organization = environment.organization;\r\n  private project = environment.project;\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  /**\r\n   * Get dashboard statistics using WIQL API for a specific iteration\r\n   * @param iterationPath The iteration path to filter by (e.g. 'Techoil\\2.3.23')\r\n   * @returns Observable with dashboard statistics including counts by status, assignee, and root cause\r\n   */\r\n  getDashboardStats(iterationPath: string): Observable<DashboardStats> {\r\n    // URL for WIQL API\r\n    const wiqlUrl = `${this.azureDevOpsUrl}/${this.organization}/${this.project}/_apis/wit/wiql?api-version=7.0`;\r\n    \r\n    // Construct WIQL query to filter by iteration path\r\n    const wiqlQuery = {\r\n      query: `SELECT [System.Id], [System.Title], [System.State], [System.WorkItemType], [System.AssignedTo], [Custom.RootCause]\r\n              FROM WorkItems\r\n              WHERE [System.IterationPath] = '${iterationPath}'\r\n              AND [System.TeamProject] = '${this.project}'`\r\n    };\r\n\r\n    // Execute WIQL query to get work item IDs\r\n    return this.http.post<WorkItemQueryResult>(wiqlUrl, wiqlQuery).pipe(\r\n      switchMap(result => {\r\n        // If no work items found, return empty stats\r\n        if (!result.workItems || result.workItems.length === 0) {\r\n          return of({\r\n            totalItems: 0,\r\n            statusCounts: {},\r\n            assigneeCounts: {},\r\n            rootCauseCounts: [],\r\n            workItems: []\r\n          });\r\n        }\r\n        \r\n        // Extract work item IDs\r\n        const ids = result.workItems.map(item => item.id);\r\n        \r\n        // URL for batch API to get full work item details\r\n        const batchUrl = `${this.azureDevOpsUrl}/${this.organization}/${this.project}/_apis/wit/workitems?ids=${ids.join(',')}&fields=System.Id,System.Title,System.State,System.WorkItemType,System.AssignedTo,Custom.RootCause&api-version=7.0`;\r\n        \r\n        // Get work item details\r\n        return this.http.get<{ value: WorkItem[] }>(batchUrl).pipe(\r\n          map(workItemsResult => {\r\n            const workItems = workItemsResult.value;\r\n            \r\n            // Process work items to calculate statistics\r\n            return this.processWorkItems(workItems);\r\n          })\r\n        );\r\n      }),\r\n      catchError(error => {\r\n        console.error('Error fetching dashboard statistics:', error);\r\n        return throwError(() => new Error('Failed to fetch dashboard statistics. Please try again.'));\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Process work items to calculate dashboard statistics\r\n   * @param workItems Array of work items to process\r\n   * @returns Dashboard statistics\r\n   */\r\n  private processWorkItems(workItems: WorkItem[]): DashboardStats {\r\n    const statusCounts: { [status: string]: number } = {};\r\n    const assigneeCounts: { \r\n      [assignee: string]: { \r\n        total: number; \r\n        states: { [state: string]: number }; \r\n      }; \r\n    } = {};\r\n    const rootCausesMap: { \r\n      [rootCause: string]: { \r\n        count: number; \r\n        states: { [state: string]: number }; \r\n      }; \r\n    } = {};\r\n\r\n    // Process each work item\r\n    workItems.forEach(item => {\r\n      const state = item.fields['System.State'] || 'Unknown';\r\n      const assignee = item.fields['System.AssignedTo'] ? \r\n                       item.fields['System.AssignedTo'].displayName : \r\n                       'Unassigned';\r\n      const rootCause = item.fields['Custom.RootCause'] || 'Unspecified';\r\n      \r\n      // Count by status\r\n      statusCounts[state] = (statusCounts[state] || 0) + 1;\r\n      \r\n      // Count by assignee and status\r\n      if (!assigneeCounts[assignee]) {\r\n        assigneeCounts[assignee] = { total: 0, states: {} };\r\n      }\r\n      assigneeCounts[assignee].total++;\r\n      assigneeCounts[assignee].states[state] = (assigneeCounts[assignee].states[state] || 0) + 1;\r\n      \r\n      // Count by root cause and status\r\n      if (!rootCausesMap[rootCause]) {\r\n        rootCausesMap[rootCause] = { count: 0, states: {} };\r\n      }\r\n      rootCausesMap[rootCause].count++;\r\n      rootCausesMap[rootCause].states[state] = (rootCausesMap[rootCause].states[state] || 0) + 1;\r\n    });\r\n\r\n    // Convert root causes to array format\r\n    const rootCauseCounts: GroupByRootCause[] = Object.keys(rootCausesMap).map(rootCause => ({\r\n      rootCause,\r\n      count: rootCausesMap[rootCause].count,\r\n      states: rootCausesMap[rootCause].states\r\n    })).sort((a, b) => b.count - a.count); // Sort by count descending\r\n\r\n    return {\r\n      totalItems: workItems.length,\r\n      statusCounts,\r\n      assigneeCounts,\r\n      rootCauseCounts,\r\n      workItems\r\n    };\r\n  }\r\n} "]},"metadata":{},"sourceType":"module","externalDependencies":[]}