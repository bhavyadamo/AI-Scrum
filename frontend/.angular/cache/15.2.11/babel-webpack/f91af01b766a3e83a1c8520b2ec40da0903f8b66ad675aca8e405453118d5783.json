{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError } from 'rxjs';\nimport { catchError, retry, map, tap } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let TaskService = /*#__PURE__*/(() => {\n  class TaskService {\n    constructor(http) {\n      this.http = http;\n      this.apiUrl = `${environment.apiUrl}/tasks`;\n    }\n    /**\r\n     * Get available iteration paths from the API\r\n     * @returns Observable of string array with iteration paths\r\n     */\n    getIterationPaths() {\n      return this.http.get(`${this.apiUrl}/iteration-paths`).pipe(retry(1), catchError(error => this.handleError(error, 'fetching iteration paths')));\n    }\n    /**\r\n     * Get work items by iteration path and optional date range\r\n     * @param iterationPath The iteration path to filter work items by\r\n     * @param fromDate Optional start date for filtering\r\n     * @param toDate Optional end date for filtering\r\n     * @returns Observable of WorkItem array\r\n     */\n    getTasks(iterationPath, fromDate, toDate) {\n      // Normalize the iteration path to handle any double backslashes\n      const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n      console.log(`Getting tasks with normalized iteration path: ${normalizedPath}`);\n      // Use HttpParams for proper URL encoding and query string building\n      // Manually encode the iterationPath to ensure backslashes are correctly encoded\n      const encodedIterationPath = encodeURIComponent(normalizedPath);\n      let params = new HttpParams().set('iterationPath', encodedIterationPath);\n      if (fromDate) {\n        params = params.set('fromDate', fromDate);\n      }\n      if (toDate) {\n        params = params.set('toDate', toDate);\n      }\n      return this.http.get(this.apiUrl, {\n        params\n      }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching work items')), map(response => this.processWorkItemsResponse(response)));\n    }\n    /**\r\n     * Get detailed information for a specific work item\r\n     * @param taskId The ID of the work item to fetch\r\n     * @returns Observable of WorkItemDetails\r\n     */\n    getTaskDetails(taskId) {\n      return this.http.get(`${this.apiUrl}/${taskId}`).pipe(retry(1), catchError(error => this.handleError(error, `fetching work item #${taskId}`)));\n    }\n    /**\r\n     * Get team members from the API\r\n     * @param iterationPath Optional iteration path to filter team members\r\n     * @returns Observable of TeamMember array or string array depending on the iterationPath\r\n     */\n    getTeamMembers(iterationPath) {\n      let params = new HttpParams();\n      if (iterationPath) {\n        // Normalize the iteration path to handle any double backslashes\n        const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n        // Manually encode the iterationPath to ensure backslashes are correctly encoded\n        const encodedIterationPath = encodeURIComponent(normalizedPath);\n        params = params.set('iterationPath', encodedIterationPath);\n      }\n      return this.http.get(`${this.apiUrl}/team-members`, {\n        params\n      }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching team members')));\n    }\n    /**\r\n     * Assign a work item to a team member\r\n     * @param taskId The ID of the work item to assign\r\n     * @param assignedTo The ID or name of the team member to assign the task to\r\n     * @returns Observable of the assignment result\r\n     */\n    assignTask(taskId, assignedTo) {\n      return this.http.post(`${this.apiUrl}/assign`, {\n        taskId,\n        assignedTo\n      }).pipe(catchError(error => this.handleError(error, `assigning work item #${taskId}`)));\n    }\n    /**\r\n     * Get auto-assign suggestions for tasks in the given iteration\r\n     * @param iterationPath The iteration path to get suggestions for\r\n     * @returns Observable of task ID to suggested assignee mapping\r\n     */\n    getAutoAssignSuggestions(iterationPath) {\n      // Normalize the iteration path to handle any double backslashes\n      const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n      console.log(`Getting auto-assign suggestions with normalized path: ${normalizedPath}`);\n      // Ensure the iterationPath is properly encoded\n      const encodedIterationPath = encodeURIComponent(normalizedPath);\n      const params = new HttpParams().set('iterationPath', encodedIterationPath);\n      return this.http.get(`${this.apiUrl}/auto-assign-suggestions`, {\n        params\n      }).pipe(tap(response => {\n        console.log('Auto-assign suggestions response:', response);\n        console.log('Suggestion keys:', Object.keys(response));\n      }), catchError(error => {\n        console.error('Error getting auto-assign suggestions:', error);\n        return this.handleError(error, 'getting auto-assign suggestions');\n      }));\n    }\n    /**\r\n     * Get auto-assign suggestions for tasks in the given iteration, filtered for specific team members\r\n     * @param iterationPath The iteration path to get suggestions for\r\n     * @param teamMembers List of team member names to consider for assignment\r\n     * @returns Observable of task ID to suggested assignee mapping\r\n     */\n    getAutoAssignSuggestionsForTeam(iterationPath, teamMembers) {\n      // Log request details for debugging\n      console.log(`Getting auto-assign suggestions for team with iteration path: ${iterationPath}`);\n      console.log(`Team members (${teamMembers.length}):`, teamMembers);\n      // Normalize the iteration path (replace double backslashes with single)\n      const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n      // Create the request body - ensure iterationPath is properly included\n      const requestBody = {\n        iterationPath: normalizedPath,\n        teamMembers: teamMembers\n      };\n      console.log('Sending request to auto-assign-suggestions/team with payload:', JSON.stringify(requestBody));\n      return this.http.post(`${this.apiUrl}/auto-assign-suggestions/team`, requestBody).pipe(tap(response => console.log('Auto-assign suggestions for team response:', response)), catchError(error => {\n        console.error('Error getting team-specific auto-assign suggestions:', error);\n        console.error('Request payload was:', JSON.stringify(requestBody));\n        return this.handleError(error, 'getting team-specific auto-assign suggestions');\n      }));\n    }\n    /**\r\n     * Auto-assign tasks in the given iteration\r\n     * @param iterationPath The iteration path containing tasks to auto-assign\r\n     * @returns Observable of the assignment result\r\n     */\n    autoAssignTasks(iterationPath) {\n      // Normalize the iteration path to handle double backslashes\n      const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n      console.log(`Auto-assigning tasks for iteration path: ${normalizedPath}`);\n      // Send the normalized path in the request body\n      return this.http.post(`${this.apiUrl}/auto-assign`, {\n        iterationPath: normalizedPath\n      }).pipe(tap(response => console.log('Auto-assign tasks response:', response)), catchError(error => {\n        console.error('Error auto-assigning tasks:', error);\n        return this.handleError(error, 'auto-assigning tasks');\n      }));\n    }\n    /**\r\n     * Get task counts for each team member in a given iteration\r\n     * @param iterationPath The iteration path to get task counts for\r\n     * @returns Observable of team member names to task count mapping\r\n     */\n    getTeamMemberTaskCounts(iterationPath) {\n      // Normalize the iteration path to handle any double backslashes\n      const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n      console.log(`Getting team member task counts with normalized path: ${normalizedPath}`);\n      // Manually encode the iterationPath to ensure backslashes are correctly encoded\n      const encodedIterationPath = encodeURIComponent(normalizedPath);\n      const params = new HttpParams().set('iterationPath', encodedIterationPath);\n      return this.http.get(`${this.apiUrl}/team-member-task-counts`, {\n        params\n      }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching team member task counts')));\n    }\n    /**\r\n     * Generic error handler for HTTP requests\r\n     * @param error The HTTP error response\r\n     * @param operation The operation that was being performed\r\n     * @returns An observable that errors with a user-friendly message\r\n     */\n    handleError(error, operation) {\n      let errorMessage = `An error occurred while ${operation}`;\n      if (error.error instanceof ErrorEvent) {\n        // Client-side error\n        errorMessage = `Error: ${error.error.message}`;\n      } else {\n        // Server-side error\n        errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\n        if (error.error?.message) {\n          errorMessage += ` - ${error.error.message}`;\n        }\n      }\n      console.error(errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n    /**\r\n     * Process the work items response to ensure consistent structure\r\n     * @param response The raw API response\r\n     * @returns An array of properly formatted WorkItem objects\r\n     */\n    processWorkItemsResponse(response) {\n      if (!Array.isArray(response)) {\n        console.warn('Unexpected response format for work items:', response);\n        return [];\n      }\n      return response.map(item => ({\n        id: item.id,\n        title: item.title || 'Untitled Work Item',\n        state: item.state || 'Unknown',\n        status: item.status,\n        type: item.type,\n        priority: item.priority || 0,\n        assignedTo: item.assignedTo || null,\n        iterationPath: item.iterationPath || ''\n      }));\n    }\n    static {\n      this.ɵfac = function TaskService_Factory(t) {\n        return new (t || TaskService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: TaskService,\n        factory: TaskService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return TaskService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}