{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError } from 'rxjs';\nimport { catchError, retry, map, tap } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TaskService {\n  constructor(http) {\n    this.http = http;\n    this.apiUrl = `${environment.apiUrl}/tasks`;\n  }\n  /**\r\n   * Get available iteration paths from the API\r\n   * @returns Observable of string array with iteration paths\r\n   */\n  getIterationPaths() {\n    return this.http.get(`${this.apiUrl}/iteration-paths`).pipe(retry(1), catchError(error => this.handleError(error, 'fetching iteration paths')));\n  }\n  /**\r\n   * Get work items by iteration path and optional date range\r\n   * @param iterationPath The iteration path to filter work items by\r\n   * @param fromDate Optional start date for filtering\r\n   * @param toDate Optional end date for filtering\r\n   * @returns Observable of WorkItem array\r\n   */\n  getTasks(iterationPath, fromDate, toDate) {\n    // Normalize the iteration path to handle any double backslashes\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n    console.log(`Getting tasks with normalized iteration path: ${normalizedPath}`);\n    // Use HttpParams for proper URL encoding and query string building\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\n    const encodedIterationPath = encodeURIComponent(normalizedPath);\n    let params = new HttpParams().set('iterationPath', encodedIterationPath);\n    if (fromDate) {\n      params = params.set('fromDate', fromDate);\n    }\n    if (toDate) {\n      params = params.set('toDate', toDate);\n    }\n    return this.http.get(this.apiUrl, {\n      params\n    }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching work items')), map(response => this.processWorkItemsResponse(response)));\n  }\n  /**\r\n   * Get detailed information for a specific work item\r\n   * @param taskId The ID of the work item to fetch\r\n   * @returns Observable of WorkItemDetails\r\n   */\n  getTaskDetails(taskId) {\n    return this.http.get(`${this.apiUrl}/${taskId}`).pipe(retry(1), catchError(error => this.handleError(error, `fetching work item #${taskId}`)));\n  }\n  /**\r\n   * Get team members from the API\r\n   * @param iterationPath Optional iteration path to filter team members\r\n   * @returns Observable of TeamMember array or string array depending on the iterationPath\r\n   */\n  getTeamMembers(iterationPath) {\n    let params = new HttpParams();\n    if (iterationPath) {\n      // Normalize the iteration path to handle any double backslashes\n      const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n      // Manually encode the iterationPath to ensure backslashes are correctly encoded\n      const encodedIterationPath = encodeURIComponent(normalizedPath);\n      params = params.set('iterationPath', encodedIterationPath);\n    }\n    return this.http.get(`${this.apiUrl}/team-members`, {\n      params\n    }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching team members')));\n  }\n  /**\r\n   * Assign a work item to a team member\r\n   * @param taskId The ID of the work item to assign\r\n   * @param assignedTo The ID or name of the team member to assign the task to\r\n   * @returns Observable of the assignment result\r\n   */\n  assignTask(taskId, assignedTo) {\n    return this.http.post(`${this.apiUrl}/assign`, {\n      taskId,\n      assignedTo\n    }).pipe(catchError(error => this.handleError(error, `assigning work item #${taskId}`)));\n  }\n  /**\r\n   * Get auto-assign suggestions for tasks in the given iteration\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @returns Observable of task ID to suggested assignee mapping\r\n   */\n  getAutoAssignSuggestions(iterationPath) {\n    // Normalize the iteration path to handle any double backslashes\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n    console.log(`Getting auto-assign suggestions with normalized path: ${normalizedPath}`);\n    // Ensure the iterationPath is properly encoded\n    const encodedIterationPath = encodeURIComponent(normalizedPath);\n    const params = new HttpParams().set('iterationPath', encodedIterationPath);\n    return this.http.get(`${this.apiUrl}/auto-assign-suggestions`, {\n      params\n    }).pipe(tap(response => {\n      console.log('Auto-assign suggestions response:', response);\n      console.log('Suggestion keys:', Object.keys(response));\n    }), catchError(error => {\n      console.error('Error getting auto-assign suggestions:', error);\n      return this.handleError(error, 'getting auto-assign suggestions');\n    }));\n  }\n  /**\r\n   * Get auto-assign suggestions for tasks in the given iteration, filtered for specific team members\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @param teamMembers List of team member names to consider for assignment\r\n   * @returns Observable of task ID to suggested assignee mapping\r\n   */\n  getAutoAssignSuggestionsForTeam(iterationPath, teamMembers) {\n    // Log request details for debugging\n    console.log(`Getting auto-assign suggestions for team with iteration path: ${iterationPath}`);\n    console.log(`Team members (${teamMembers.length}):`, teamMembers);\n    // Normalize the iteration path (replace double backslashes with single)\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n    // Create the request body - ensure iterationPath is properly included\n    const requestBody = {\n      iterationPath: normalizedPath,\n      teamMembers: teamMembers\n    };\n    console.log('Sending request to auto-assign-suggestions/team with payload:', JSON.stringify(requestBody));\n    return this.http.post(`${this.apiUrl}/auto-assign-suggestions/team`, requestBody).pipe(tap(response => console.log('Auto-assign suggestions for team response:', response)), catchError(error => {\n      console.error('Error getting team-specific auto-assign suggestions:', error);\n      console.error('Request payload was:', JSON.stringify(requestBody));\n      return this.handleError(error, 'getting team-specific auto-assign suggestions');\n    }));\n  }\n  /**\r\n   * Auto-assign tasks in the given iteration\r\n   * @param iterationPath The iteration path containing tasks to auto-assign\r\n   * @returns Observable of the assignment result\r\n   */\n  autoAssignTasks(iterationPath) {\n    // Normalize the iteration path to handle double backslashes\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n    console.log(`Auto-assigning tasks for iteration path: ${normalizedPath}`);\n    // Send the normalized path in the request body\n    return this.http.post(`${this.apiUrl}/auto-assign`, {\n      iterationPath: normalizedPath\n    }).pipe(tap(response => console.log('Auto-assign tasks response:', response)), catchError(error => {\n      console.error('Error auto-assigning tasks:', error);\n      return this.handleError(error, 'auto-assigning tasks');\n    }));\n  }\n  /**\r\n   * Get task counts for each team member in a given iteration\r\n   * @param iterationPath The iteration path to get task counts for\r\n   * @returns Observable of team member names to task count mapping\r\n   */\n  getTeamMemberTaskCounts(iterationPath) {\n    // Normalize the iteration path to handle any double backslashes\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\n    console.log(`Getting team member task counts with normalized path: ${normalizedPath}`);\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\n    const encodedIterationPath = encodeURIComponent(normalizedPath);\n    const params = new HttpParams().set('iterationPath', encodedIterationPath);\n    return this.http.get(`${this.apiUrl}/team-member-task-counts`, {\n      params\n    }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching team member task counts')));\n  }\n  /**\r\n   * Get work item history data for a specific iteration\r\n   * This uses the existing getTasks endpoint but looks for completed work items\r\n   * @param iterationPath The iteration path to get history for\r\n   * @returns Observable of work items that can be used for historical analysis\r\n   */\n  getTaskHistory(iterationPath) {\n    // For now, we'll use the regular getTasks method since the history endpoint isn't available\n    console.log('Getting historical work items from iteration: ' + iterationPath);\n    // We use the existing endpoint but will process the data to extract historical information\n    return this.getTasks(iterationPath).pipe(map(items => {\n      console.log(`Received ${items.length} items for historical analysis`);\n      // Filter to only include completed work items that would have historical data\n      const completedItems = items.filter(item => {\n        const state = item.state?.toLowerCase() || '';\n        return state.includes('done') || state.includes('closed') || state.includes('complete') || state.includes('resolved');\n      });\n      console.log(`Found ${completedItems.length} completed items with potential historical data`);\n      return completedItems;\n    }));\n  }\n  /**\r\n   * Generic error handler for HTTP requests\r\n   * @param error The HTTP error response\r\n   * @param operation The operation that was being performed\r\n   * @returns An observable that errors with a user-friendly message\r\n   */\n  handleError(error, operation) {\n    let errorMessage = `An error occurred while ${operation}`;\n    if (error.error instanceof ErrorEvent) {\n      // Client-side error\n      errorMessage = `Error: ${error.error.message}`;\n    } else {\n      // Server-side error\n      errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\n      if (error.error?.message) {\n        errorMessage += ` - ${error.error.message}`;\n      }\n    }\n    console.error(errorMessage);\n    return throwError(() => new Error(errorMessage));\n  }\n  /**\r\n   * Process the work items response to ensure consistent structure\r\n   * @param response The raw API response\r\n   * @returns An array of properly formatted WorkItem objects\r\n   */\n  processWorkItemsResponse(response) {\n    if (!Array.isArray(response)) {\n      console.warn('Unexpected response format for work items:', response);\n      return [];\n    }\n    return response.map(item => ({\n      id: item.id,\n      title: item.title || 'Untitled Work Item',\n      state: item.state || 'Unknown',\n      status: item.status,\n      type: item.type,\n      priority: item.priority || 0,\n      assignedTo: item.assignedTo || null,\n      iterationPath: item.iterationPath || ''\n    }));\n  }\n  static {\n    this.ɵfac = function TaskService_Factory(t) {\n      return new (t || TaskService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TaskService,\n      factory: TaskService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["HttpParams","throwError","catchError","retry","map","tap","environment","TaskService","constructor","http","apiUrl","getIterationPaths","get","pipe","error","handleError","getTasks","iterationPath","fromDate","toDate","normalizedPath","replace","console","log","encodedIterationPath","encodeURIComponent","params","set","response","processWorkItemsResponse","getTaskDetails","taskId","getTeamMembers","assignTask","assignedTo","post","getAutoAssignSuggestions","Object","keys","getAutoAssignSuggestionsForTeam","teamMembers","length","requestBody","JSON","stringify","autoAssignTasks","getTeamMemberTaskCounts","getTaskHistory","items","completedItems","filter","item","state","toLowerCase","includes","operation","errorMessage","ErrorEvent","message","status","statusText","Error","Array","isArray","warn","id","title","type","priority","factory","providedIn"],"sourceRoot":"","sources":["E:\\Project-AI\\AI-Scrum\\frontend\\src\\app\\services\\task.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';\r\nimport { Observable, throwError } from 'rxjs';\r\nimport { catchError, retry, map, tap } from 'rxjs/operators';\r\nimport { WorkItem, WorkItemDetails, TeamMember } from '../models/task.model';\r\nimport { environment } from '../../environments/environment';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class TaskService {\r\n  private apiUrl = `${environment.apiUrl}/tasks`;\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  /**\r\n   * Get available iteration paths from the API\r\n   * @returns Observable of string array with iteration paths\r\n   */\r\n  getIterationPaths(): Observable<string[]> {\r\n    return this.http.get<string[]>(`${this.apiUrl}/iteration-paths`)\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching iteration paths'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get work items by iteration path and optional date range\r\n   * @param iterationPath The iteration path to filter work items by\r\n   * @param fromDate Optional start date for filtering\r\n   * @param toDate Optional end date for filtering\r\n   * @returns Observable of WorkItem array\r\n   */\r\n  getTasks(iterationPath: string, fromDate?: string, toDate?: string): Observable<WorkItem[]> {\r\n    // Normalize the iteration path to handle any double backslashes\r\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\r\n    console.log(`Getting tasks with normalized iteration path: ${normalizedPath}`);\r\n    \r\n    // Use HttpParams for proper URL encoding and query string building\r\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\r\n    const encodedIterationPath = encodeURIComponent(normalizedPath);\r\n    let params = new HttpParams().set('iterationPath', encodedIterationPath);\r\n    \r\n    if (fromDate) {\r\n      params = params.set('fromDate', fromDate);\r\n    }\r\n    \r\n    if (toDate) {\r\n      params = params.set('toDate', toDate);\r\n    }\r\n    \r\n    return this.http.get<WorkItem[]>(this.apiUrl, { params })\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching work items')),\r\n        map(response => this.processWorkItemsResponse(response))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get detailed information for a specific work item\r\n   * @param taskId The ID of the work item to fetch\r\n   * @returns Observable of WorkItemDetails\r\n   */\r\n  getTaskDetails(taskId: number): Observable<WorkItemDetails> {\r\n    return this.http.get<WorkItemDetails>(`${this.apiUrl}/${taskId}`)\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, `fetching work item #${taskId}`))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get team members from the API\r\n   * @param iterationPath Optional iteration path to filter team members\r\n   * @returns Observable of TeamMember array or string array depending on the iterationPath\r\n   */\r\n  getTeamMembers(iterationPath?: string): Observable<TeamMember[] | string[]> {\r\n    let params = new HttpParams();\r\n    \r\n    if (iterationPath) {\r\n      // Normalize the iteration path to handle any double backslashes\r\n      const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\r\n      \r\n      // Manually encode the iterationPath to ensure backslashes are correctly encoded\r\n      const encodedIterationPath = encodeURIComponent(normalizedPath);\r\n      params = params.set('iterationPath', encodedIterationPath);\r\n    }\r\n    \r\n    return this.http.get<TeamMember[] | string[]>(`${this.apiUrl}/team-members`, { params })\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching team members'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Assign a work item to a team member\r\n   * @param taskId The ID of the work item to assign\r\n   * @param assignedTo The ID or name of the team member to assign the task to\r\n   * @returns Observable of the assignment result\r\n   */\r\n  assignTask(taskId: number, assignedTo: string): Observable<any> {\r\n    return this.http.post<any>(`${this.apiUrl}/assign`, {\r\n      taskId,\r\n      assignedTo\r\n    }).pipe(\r\n      catchError(error => this.handleError(error, `assigning work item #${taskId}`))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get auto-assign suggestions for tasks in the given iteration\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @returns Observable of task ID to suggested assignee mapping\r\n   */\r\n  getAutoAssignSuggestions(iterationPath: string): Observable<Record<string, string>> {\r\n    // Normalize the iteration path to handle any double backslashes\r\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\r\n    console.log(`Getting auto-assign suggestions with normalized path: ${normalizedPath}`);\r\n    \r\n    // Ensure the iterationPath is properly encoded\r\n    const encodedIterationPath = encodeURIComponent(normalizedPath);\r\n    const params = new HttpParams().set('iterationPath', encodedIterationPath);\r\n    \r\n    return this.http.get<Record<string, string>>(`${this.apiUrl}/auto-assign-suggestions`, { params }).pipe(\r\n      tap(response => {\r\n        console.log('Auto-assign suggestions response:', response);\r\n        console.log('Suggestion keys:', Object.keys(response));\r\n      }),\r\n      catchError(error => {\r\n        console.error('Error getting auto-assign suggestions:', error);\r\n        return this.handleError(error, 'getting auto-assign suggestions');\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get auto-assign suggestions for tasks in the given iteration, filtered for specific team members\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @param teamMembers List of team member names to consider for assignment\r\n   * @returns Observable of task ID to suggested assignee mapping\r\n   */\r\n  getAutoAssignSuggestionsForTeam(iterationPath: string, teamMembers: string[]): Observable<Record<string, string>> {\r\n    // Log request details for debugging\r\n    console.log(`Getting auto-assign suggestions for team with iteration path: ${iterationPath}`);\r\n    console.log(`Team members (${teamMembers.length}):`, teamMembers);\r\n    \r\n    // Normalize the iteration path (replace double backslashes with single)\r\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\r\n    \r\n    // Create the request body - ensure iterationPath is properly included\r\n    const requestBody = {\r\n      iterationPath: normalizedPath,\r\n      teamMembers: teamMembers\r\n    };\r\n\r\n    console.log('Sending request to auto-assign-suggestions/team with payload:', JSON.stringify(requestBody));\r\n    \r\n    return this.http.post<Record<string, string>>(`${this.apiUrl}/auto-assign-suggestions/team`, requestBody)\r\n      .pipe(\r\n        tap(response => console.log('Auto-assign suggestions for team response:', response)),\r\n        catchError(error => {\r\n          console.error('Error getting team-specific auto-assign suggestions:', error);\r\n          console.error('Request payload was:', JSON.stringify(requestBody));\r\n          return this.handleError(error, 'getting team-specific auto-assign suggestions');\r\n        })\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Auto-assign tasks in the given iteration\r\n   * @param iterationPath The iteration path containing tasks to auto-assign\r\n   * @returns Observable of the assignment result\r\n   */\r\n  autoAssignTasks(iterationPath: string): Observable<any> {\r\n    // Normalize the iteration path to handle double backslashes\r\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\r\n    \r\n    console.log(`Auto-assigning tasks for iteration path: ${normalizedPath}`);\r\n    \r\n    // Send the normalized path in the request body\r\n    return this.http.post<any>(`${this.apiUrl}/auto-assign`, {\r\n      iterationPath: normalizedPath\r\n    }).pipe(\r\n      tap(response => console.log('Auto-assign tasks response:', response)),\r\n      catchError(error => {\r\n        console.error('Error auto-assigning tasks:', error);\r\n        return this.handleError(error, 'auto-assigning tasks');\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get task counts for each team member in a given iteration\r\n   * @param iterationPath The iteration path to get task counts for\r\n   * @returns Observable of team member names to task count mapping\r\n   */\r\n  getTeamMemberTaskCounts(iterationPath: string): Observable<Record<string, number>> {\r\n    // Normalize the iteration path to handle any double backslashes\r\n    const normalizedPath = iterationPath.replace(/\\\\\\\\/g, '\\\\');\r\n    console.log(`Getting team member task counts with normalized path: ${normalizedPath}`);\r\n    \r\n    // Manually encode the iterationPath to ensure backslashes are correctly encoded\r\n    const encodedIterationPath = encodeURIComponent(normalizedPath);\r\n    const params = new HttpParams().set('iterationPath', encodedIterationPath);\r\n\r\n    return this.http.get<Record<string, number>>(`${this.apiUrl}/team-member-task-counts`, { params })\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching team member task counts'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get work item history data for a specific iteration\r\n   * This uses the existing getTasks endpoint but looks for completed work items\r\n   * @param iterationPath The iteration path to get history for\r\n   * @returns Observable of work items that can be used for historical analysis\r\n   */\r\n  getTaskHistory(iterationPath: string): Observable<WorkItem[]> {\r\n    // For now, we'll use the regular getTasks method since the history endpoint isn't available\r\n    console.log('Getting historical work items from iteration: ' + iterationPath);\r\n    \r\n    // We use the existing endpoint but will process the data to extract historical information\r\n    return this.getTasks(iterationPath).pipe(\r\n      map(items => {\r\n        console.log(`Received ${items.length} items for historical analysis`);\r\n        \r\n        // Filter to only include completed work items that would have historical data\r\n        const completedItems = items.filter(item => {\r\n          const state = item.state?.toLowerCase() || '';\r\n          return state.includes('done') || \r\n                 state.includes('closed') || \r\n                 state.includes('complete') ||\r\n                 state.includes('resolved');\r\n        });\r\n        \r\n        console.log(`Found ${completedItems.length} completed items with potential historical data`);\r\n        return completedItems;\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generic error handler for HTTP requests\r\n   * @param error The HTTP error response\r\n   * @param operation The operation that was being performed\r\n   * @returns An observable that errors with a user-friendly message\r\n   */\r\n  private handleError(error: HttpErrorResponse, operation: string): Observable<never> {\r\n    let errorMessage = `An error occurred while ${operation}`;\r\n    \r\n    if (error.error instanceof ErrorEvent) {\r\n      // Client-side error\r\n      errorMessage = `Error: ${error.error.message}`;\r\n    } else {\r\n      // Server-side error\r\n      errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\r\n      if (error.error?.message) {\r\n        errorMessage += ` - ${error.error.message}`;\r\n      }\r\n    }\r\n    \r\n    console.error(errorMessage);\r\n    return throwError(() => new Error(errorMessage));\r\n  }\r\n\r\n  /**\r\n   * Process the work items response to ensure consistent structure\r\n   * @param response The raw API response\r\n   * @returns An array of properly formatted WorkItem objects\r\n   */\r\n  private processWorkItemsResponse(response: any): WorkItem[] {\r\n    if (!Array.isArray(response)) {\r\n      console.warn('Unexpected response format for work items:', response);\r\n      return [];\r\n    }\r\n    \r\n    return response.map(item => ({\r\n      id: item.id,\r\n      title: item.title || 'Untitled Work Item',\r\n      state: item.state || 'Unknown',\r\n      status: item.status,\r\n      type: item.type,\r\n      priority: item.priority || 0,\r\n      assignedTo: item.assignedTo || null,\r\n      iterationPath: item.iterationPath || '',\r\n    }));\r\n  }\r\n} "]},"metadata":{},"sourceType":"module","externalDependencies":[]}