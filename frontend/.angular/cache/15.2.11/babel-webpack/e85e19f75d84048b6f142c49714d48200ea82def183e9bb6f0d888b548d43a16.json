{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError } from 'rxjs';\nimport { catchError, retry, map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TaskService {\n  constructor(http) {\n    this.http = http;\n    this.apiUrl = `${environment.apiUrl}/work-items`;\n  }\n  /**\r\n   * Get work items by iteration path and optional date range\r\n   * @param iterationPath The iteration path to filter work items by\r\n   * @param fromDate Optional start date for filtering\r\n   * @param toDate Optional end date for filtering\r\n   * @returns Observable of WorkItem array\r\n   */\n  getTasks(iterationPath, fromDate, toDate) {\n    // Use HttpParams for proper URL encoding and query string building\n    let params = new HttpParams().set('iterationPath', iterationPath);\n    if (fromDate) {\n      params = params.set('fromDate', fromDate);\n    }\n    if (toDate) {\n      params = params.set('toDate', toDate);\n    }\n    return this.http.get(this.apiUrl, {\n      params\n    }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching work items')), map(response => this.processWorkItemsResponse(response)));\n  }\n  /**\r\n   * Get detailed information for a specific work item\r\n   * @param taskId The ID of the work item to fetch\r\n   * @returns Observable of WorkItemDetails\r\n   */\n  getTaskDetails(taskId) {\n    return this.http.get(`${this.apiUrl}/${taskId}`).pipe(retry(1), catchError(error => this.handleError(error, `fetching work item #${taskId}`)));\n  }\n  /**\r\n   * Get team members from the API\r\n   * @returns Observable of TeamMember array\r\n   * @deprecated Use TeamService.getTeamMembers() instead\r\n   */\n  getTeamMembers() {\n    return this.http.get(`${this.apiUrl}/team-members`).pipe(retry(1), catchError(error => this.handleError(error, 'fetching team members')));\n  }\n  /**\r\n   * Assign a work item to a team member\r\n   * @param taskId The ID of the work item to assign\r\n   * @param assignedTo The ID or name of the team member to assign the task to\r\n   * @returns Observable of the assignment result\r\n   */\n  assignTask(taskId, assignedTo) {\n    return this.http.post(`${this.apiUrl}/assign`, {\n      taskId,\n      assignedTo\n    }).pipe(catchError(error => this.handleError(error, `assigning work item #${taskId}`)));\n  }\n  /**\r\n   * Get auto-assignment suggestions for tasks in the given iteration\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @returns Observable of task ID to team member ID mapping\r\n   */\n  getAutoAssignSuggestions(iterationPath) {\n    const params = new HttpParams().set('iterationPath', iterationPath);\n    return this.http.get(`${this.apiUrl}/auto-assign-suggestions`, {\n      params\n    }).pipe(catchError(error => this.handleError(error, 'fetching auto-assign suggestions')));\n  }\n  /**\r\n   * Auto-assign tasks in the given iteration\r\n   * @param iterationPath The iteration path containing tasks to auto-assign\r\n   * @returns Observable of the assignment result\r\n   */\n  autoAssignTasks(iterationPath) {\n    return this.http.post(`${this.apiUrl}/auto-assign`, {\n      iterationPath\n    }).pipe(catchError(error => this.handleError(error, 'auto-assigning tasks')));\n  }\n  /**\r\n   * Generic error handler for HTTP requests\r\n   * @param error The HTTP error response\r\n   * @param operation The operation that was being performed\r\n   * @returns An observable that errors with a user-friendly message\r\n   */\n  handleError(error, operation) {\n    let errorMessage = `An error occurred while ${operation}`;\n    if (error.error instanceof ErrorEvent) {\n      // Client-side error\n      errorMessage = `Error: ${error.error.message}`;\n    } else {\n      // Server-side error\n      errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\n      if (error.error?.message) {\n        errorMessage += ` - ${error.error.message}`;\n      }\n    }\n    console.error(errorMessage);\n    return throwError(() => new Error(errorMessage));\n  }\n  /**\r\n   * Process the work items response to ensure consistent structure\r\n   * @param response The raw API response\r\n   * @returns An array of properly formatted WorkItem objects\r\n   */\n  processWorkItemsResponse(response) {\n    if (!Array.isArray(response)) {\n      console.warn('Unexpected response format for work items:', response);\n      return [];\n    }\n    return response.map(item => ({\n      id: item.id,\n      title: item.title || 'Untitled Work Item',\n      state: item.state || 'Unknown',\n      status: item.status,\n      type: item.type,\n      priority: item.priority || 0,\n      assignedTo: item.assignedTo || null,\n      iterationPath: item.iterationPath || ''\n    }));\n  }\n  static {\n    this.ɵfac = function TaskService_Factory(t) {\n      return new (t || TaskService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TaskService,\n      factory: TaskService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["HttpParams","throwError","catchError","retry","map","environment","TaskService","constructor","http","apiUrl","getTasks","iterationPath","fromDate","toDate","params","set","get","pipe","error","handleError","response","processWorkItemsResponse","getTaskDetails","taskId","getTeamMembers","assignTask","assignedTo","post","getAutoAssignSuggestions","autoAssignTasks","operation","errorMessage","ErrorEvent","message","status","statusText","console","Error","Array","isArray","warn","item","id","title","state","type","priority","factory","providedIn"],"sourceRoot":"","sources":["E:\\Project-AI\\AI-Scrum\\frontend\\src\\app\\services\\task.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';\r\nimport { Observable, throwError } from 'rxjs';\r\nimport { catchError, retry, map } from 'rxjs/operators';\r\nimport { WorkItem, WorkItemDetails, TeamMember } from '../models/task.model';\r\nimport { environment } from '../../environments/environment';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class TaskService {\r\n  private apiUrl = `${environment.apiUrl}/work-items`;\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  /**\r\n   * Get work items by iteration path and optional date range\r\n   * @param iterationPath The iteration path to filter work items by\r\n   * @param fromDate Optional start date for filtering\r\n   * @param toDate Optional end date for filtering\r\n   * @returns Observable of WorkItem array\r\n   */\r\n  getTasks(iterationPath: string, fromDate?: string, toDate?: string): Observable<WorkItem[]> {\r\n    // Use HttpParams for proper URL encoding and query string building\r\n    let params = new HttpParams().set('iterationPath', iterationPath);\r\n    \r\n    if (fromDate) {\r\n      params = params.set('fromDate', fromDate);\r\n    }\r\n    \r\n    if (toDate) {\r\n      params = params.set('toDate', toDate);\r\n    }\r\n    \r\n    return this.http.get<WorkItem[]>(this.apiUrl, { params })\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching work items')),\r\n        map(response => this.processWorkItemsResponse(response))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get detailed information for a specific work item\r\n   * @param taskId The ID of the work item to fetch\r\n   * @returns Observable of WorkItemDetails\r\n   */\r\n  getTaskDetails(taskId: number): Observable<WorkItemDetails> {\r\n    return this.http.get<WorkItemDetails>(`${this.apiUrl}/${taskId}`)\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, `fetching work item #${taskId}`))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Get team members from the API\r\n   * @returns Observable of TeamMember array\r\n   * @deprecated Use TeamService.getTeamMembers() instead\r\n   */\r\n  getTeamMembers(): Observable<TeamMember[]> {\r\n    return this.http.get<TeamMember[]>(`${this.apiUrl}/team-members`)\r\n      .pipe(\r\n        retry(1),\r\n        catchError(error => this.handleError(error, 'fetching team members'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Assign a work item to a team member\r\n   * @param taskId The ID of the work item to assign\r\n   * @param assignedTo The ID or name of the team member to assign the task to\r\n   * @returns Observable of the assignment result\r\n   */\r\n  assignTask(taskId: number, assignedTo: string): Observable<any> {\r\n    return this.http.post<any>(`${this.apiUrl}/assign`, {\r\n      taskId,\r\n      assignedTo\r\n    }).pipe(\r\n      catchError(error => this.handleError(error, `assigning work item #${taskId}`))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get auto-assignment suggestions for tasks in the given iteration\r\n   * @param iterationPath The iteration path to get suggestions for\r\n   * @returns Observable of task ID to team member ID mapping\r\n   */\r\n  getAutoAssignSuggestions(iterationPath: string): Observable<Record<string, string>> {\r\n    const params = new HttpParams().set('iterationPath', iterationPath);\r\n\r\n    return this.http.get<Record<string, string>>(`${this.apiUrl}/auto-assign-suggestions`, { params })\r\n      .pipe(\r\n        catchError(error => this.handleError(error, 'fetching auto-assign suggestions'))\r\n      );\r\n  }\r\n\r\n  /**\r\n   * Auto-assign tasks in the given iteration\r\n   * @param iterationPath The iteration path containing tasks to auto-assign\r\n   * @returns Observable of the assignment result\r\n   */\r\n  autoAssignTasks(iterationPath: string): Observable<any> {\r\n    return this.http.post<any>(`${this.apiUrl}/auto-assign`, {\r\n      iterationPath\r\n    }).pipe(\r\n      catchError(error => this.handleError(error, 'auto-assigning tasks'))\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generic error handler for HTTP requests\r\n   * @param error The HTTP error response\r\n   * @param operation The operation that was being performed\r\n   * @returns An observable that errors with a user-friendly message\r\n   */\r\n  private handleError(error: HttpErrorResponse, operation: string): Observable<never> {\r\n    let errorMessage = `An error occurred while ${operation}`;\r\n    \r\n    if (error.error instanceof ErrorEvent) {\r\n      // Client-side error\r\n      errorMessage = `Error: ${error.error.message}`;\r\n    } else {\r\n      // Server-side error\r\n      errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\r\n      if (error.error?.message) {\r\n        errorMessage += ` - ${error.error.message}`;\r\n      }\r\n    }\r\n    \r\n    console.error(errorMessage);\r\n    return throwError(() => new Error(errorMessage));\r\n  }\r\n\r\n  /**\r\n   * Process the work items response to ensure consistent structure\r\n   * @param response The raw API response\r\n   * @returns An array of properly formatted WorkItem objects\r\n   */\r\n  private processWorkItemsResponse(response: any): WorkItem[] {\r\n    if (!Array.isArray(response)) {\r\n      console.warn('Unexpected response format for work items:', response);\r\n      return [];\r\n    }\r\n    \r\n    return response.map(item => ({\r\n      id: item.id,\r\n      title: item.title || 'Untitled Work Item',\r\n      state: item.state || 'Unknown',\r\n      status: item.status,\r\n      type: item.type,\r\n      priority: item.priority || 0,\r\n      assignedTo: item.assignedTo || null,\r\n      iterationPath: item.iterationPath || '',\r\n    }));\r\n  }\r\n} "]},"metadata":{},"sourceType":"module","externalDependencies":[]}