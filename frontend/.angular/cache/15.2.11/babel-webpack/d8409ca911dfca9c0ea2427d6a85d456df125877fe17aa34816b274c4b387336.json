{"ast":null,"code":"import { HttpParams } from '@angular/common/http';\nimport { throwError } from 'rxjs';\nimport { catchError, retry, map } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let TaskService = /*#__PURE__*/(() => {\n  class TaskService {\n    constructor(http) {\n      this.http = http;\n      this.apiUrl = `${environment.apiUrl}/work-items`;\n    }\n    /**\r\n     * Get work items by iteration path and optional date range\r\n     * @param iterationPath The iteration path to filter work items by\r\n     * @param fromDate Optional start date for filtering\r\n     * @param toDate Optional end date for filtering\r\n     * @returns Observable of WorkItem array\r\n     */\n    getTasks(iterationPath, fromDate, toDate) {\n      // Use HttpParams for proper URL encoding and query string building\n      let params = new HttpParams().set('iterationPath', iterationPath);\n      if (fromDate) {\n        params = params.set('fromDate', fromDate);\n      }\n      if (toDate) {\n        params = params.set('toDate', toDate);\n      }\n      return this.http.get(this.apiUrl, {\n        params\n      }).pipe(retry(1), catchError(error => this.handleError(error, 'fetching work items')), map(response => this.processWorkItemsResponse(response)));\n    }\n    /**\r\n     * Get detailed information for a specific work item\r\n     * @param taskId The ID of the work item to fetch\r\n     * @returns Observable of WorkItemDetails\r\n     */\n    getTaskDetails(taskId) {\n      return this.http.get(`${this.apiUrl}/${taskId}`).pipe(retry(1), catchError(error => this.handleError(error, `fetching work item #${taskId}`)));\n    }\n    /**\r\n     * Get team members from the API\r\n     * @returns Observable of TeamMember array\r\n     * @deprecated Use TeamService.getTeamMembers() instead\r\n     */\n    getTeamMembers() {\n      return this.http.get(`${this.apiUrl}/team-members`).pipe(retry(1), catchError(error => this.handleError(error, 'fetching team members')));\n    }\n    /**\r\n     * Assign a work item to a team member\r\n     * @param taskId The ID of the work item to assign\r\n     * @param assignedTo The ID or name of the team member to assign the task to\r\n     * @returns Observable of the assignment result\r\n     */\n    assignTask(taskId, assignedTo) {\n      return this.http.post(`${this.apiUrl}/assign`, {\n        taskId,\n        assignedTo\n      }).pipe(catchError(error => this.handleError(error, `assigning work item #${taskId}`)));\n    }\n    /**\r\n     * Get auto-assignment suggestions for tasks in the given iteration\r\n     * @param iterationPath The iteration path to get suggestions for\r\n     * @returns Observable of task ID to team member ID mapping\r\n     */\n    getAutoAssignSuggestions(iterationPath) {\n      const params = new HttpParams().set('iterationPath', iterationPath);\n      return this.http.get(`${this.apiUrl}/auto-assign-suggestions`, {\n        params\n      }).pipe(catchError(error => this.handleError(error, 'fetching auto-assign suggestions')));\n    }\n    /**\r\n     * Auto-assign tasks in the given iteration\r\n     * @param iterationPath The iteration path containing tasks to auto-assign\r\n     * @returns Observable of the assignment result\r\n     */\n    autoAssignTasks(iterationPath) {\n      return this.http.post(`${this.apiUrl}/auto-assign`, {\n        iterationPath\n      }).pipe(catchError(error => this.handleError(error, 'auto-assigning tasks')));\n    }\n    /**\r\n     * Generic error handler for HTTP requests\r\n     * @param error The HTTP error response\r\n     * @param operation The operation that was being performed\r\n     * @returns An observable that errors with a user-friendly message\r\n     */\n    handleError(error, operation) {\n      let errorMessage = `An error occurred while ${operation}`;\n      if (error.error instanceof ErrorEvent) {\n        // Client-side error\n        errorMessage = `Error: ${error.error.message}`;\n      } else {\n        // Server-side error\n        errorMessage = `Server returned code ${error.status}: ${error.statusText}`;\n        if (error.error?.message) {\n          errorMessage += ` - ${error.error.message}`;\n        }\n      }\n      console.error(errorMessage);\n      return throwError(() => new Error(errorMessage));\n    }\n    /**\r\n     * Process the work items response to ensure consistent structure\r\n     * @param response The raw API response\r\n     * @returns An array of properly formatted WorkItem objects\r\n     */\n    processWorkItemsResponse(response) {\n      if (!Array.isArray(response)) {\n        console.warn('Unexpected response format for work items:', response);\n        return [];\n      }\n      return response.map(item => ({\n        id: item.id,\n        title: item.title || 'Untitled Work Item',\n        state: item.state || 'Unknown',\n        status: item.status,\n        type: item.type,\n        priority: item.priority || 0,\n        assignedTo: item.assignedTo || null,\n        iterationPath: item.iterationPath || ''\n      }));\n    }\n    static {\n      this.ɵfac = function TaskService_Factory(t) {\n        return new (t || TaskService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: TaskService,\n        factory: TaskService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return TaskService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}